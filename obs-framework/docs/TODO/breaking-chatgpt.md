```js
title = md`# Breaking ChatGPT`
```

Here you see a potentially long but predictable story about people and their encounters. I enjoyed copying the story's text version as a prompt to ChatGPT and see how it fails.

The story is generated by a loop, depending on the length that you can set here.

The diagram is not used by ChatGPT. It serves as a visual representation of the story, which I find easier to understand (at moderate lengths).

## define the difficulty for ChatGPT

```js
viewof chapters = Inputs.range( [3,300], {value:6, step:1, label: "length (number of people)", minValue:3, max:300} )
```

```js
viewof include_hotel = Inputs.checkbox( ["yes"], {label: "include hotel (non-linear version)", value:["yes"]} )
```

## resulting story (text format)

```js
Inputs.button( "copy to clipboard (then paste in your favourite AI)", {reduce: () => navigator.clipboard.writeText(narration) } ) 
```

```js
narration
```

## visual story

```js
diagram = dot2svg( new StoryToDotRenderer( theStory ) )
```

```js
command_sequence = `e,M,M,N,${[...theStory.events.keys()].slice(-1)[0]},${theStory.entity_keys[ samples[1] ]}_future,i,place0,${theStory.entity_keys[ samples[0] ]}_future,i,Escape`
```

Notes on the diagram:
1. time flows bottom-up

1. therefore, causality flows bottom-up

1. therefore, information about places flows bottom-up

1. each person's "final" knowledge is represented in the topmost box "PersonX"

1. the diagram is colored according based on selected available knowledge (reasoning)

- - -

## my findings

1. ChatGPT performs well at long, predictable chains of induction. 

1. Introducing one irregular path (the hotel) confuses ChatGPT 3.5 easily and ChatGPT 4 at longer chains.

1. Stories which are easy to understand for a human already beat ChatGPT 3.5.

1. A human can work through a long chain of events relatively easily (it just takes time and is boring). ChatGPT's attention span is limited. At a certain length of the chain, it breaks: answers will go completely wrong even though ChatGPT accepts then input.

1. **ChatGPT does not admit when a story gets too complex.** It will just hallucinate answers that sound reasonable but are wrong (quote ChatGPT 4: _"On the other hand, Person200 has no knowledge of place0 as they have not met Person1 or anyone below Person100 who would have information about place0"_). Fact is: every single person knows about place0, through the travellers that they met earlier.

## takeaways

1. I believe it is important to know how complex of a task ChatGPT can handle reliably. In the case of these connected scenarios I was surprised to see ChatGPT 3.5 failing quite early and **ChatGPT 4 failing at longer chains**. Imagine an AI running your business, based on knowledge of internal **value chains** that depend on each other. Let alone **supply chains**, or giving advice on **global challenges**...

1. **Knowledge Graphs** are absolutely vital to inform People and machines about connections, contributions and dependencies. In many scenarios a Knowledge Graph **can easily explain** what a LLM can't, when it comes to linked information and reasoning.

## why "the hotel"?

ChatGPT 3.5 did very well before I introduced the "hotel" episode. A completely linear story was too easy to solve. So I introduced this non-linear branch: _The very last person in the story, and a person in the upper third, both meet at the hotel at the very end. So that upper-third person is privileged to know also about the last place (before the hotel)._ 

In my prompt I always ask about a lower-third person (who cannot know about the places in the two upper thirds) and the upper-third person about their knowledge of the first and the last place. In my tests, ChatGPT 4 can handle chains up to 150 chapters correctly but fails at 300.

```js
curtain = md`
- - -`
```

## _Implementation_

```js
narration = 
{
  // keep track of the events which need to be told (true) or have already been told (false)
  const eventsToTell = new Map( [...theStory.events.keys()].map( e => [e, true] ) )

  return `
Here is a story about world travellers who meet other travellers.
This type of people never visit the same place twice.

When people meet then they talk about life, universe and everything. 
Also about every previous place where they have been, 
 and about every other person who they have met previously, 
 and about those other people's stories.
` + 
theStory.entity_keys
.reduce
( (a,ent) => 
  a + "\n" + ent +
  theStory.entity_timelines[ent].events
 
  // I found that ChatGPT has a hard time understanding the story, 
  // if I omit the redundant encounters from the perspective of the other entities
  // - thus the "as we know" infix for those redundant encounters
  //.filter( e => eventsToTell.get( e ) ) 

  .reduce
  ( (a, ev) =>
    {
      const result = a + (a ? ", and later" : "") + tellabout()
      eventsToTell.set( ev, false )
      return result

      function tellabout()
      {
        const others = [...theStory.event_entity_map.get( ev ).keys()].filter( ent2 => ent2 != ent )
        return (others.length ? " meets  " + others.join(' and ') + " at" : " visits")
          + " " + ev + (eventsToTell.get(ev) ? "" : " (as we know)")
      }
    }
    , "" // accumulator
  ) + "."
  ,   "" // accumulator
) + `

I am curious: what do ${theStory.entity_keys[ samples[0] ]} and ${theStory.entity_keys[ samples[1] ]} each know about ${[...eventsToTell.keys()][0]} and about ${[...eventsToTell.keys()].slice(-1)[0]} ?
`
}
```

```js
highlight_key_events = {
  diagram;
  visco.on_svg_load()
  visco.execute_command_sequence( command_sequence )
}
```

```js
theStory = new Story(
  automatic_timelines_text 
)
```

```js
automatic_timelines_text = 
Array.apply(null, Array(chapters)).map((x, i) => i).map
( (t,i) => 
  `Person${t+1} place${t} place${t+1}${ include_hotel.length && (i == chapters-1 || i == samples[1]) ? ' theHotel' : "" }`
).join("\n\n")
```

```js
samples = 
[
  Math.round(chapters  /3)-1
  ,
  Math.round(chapters*2/3)-1
]
```

## Imports

```js
css2xhr
```

```js
import { css2xhr } from "@bogo/css-hide-after-double-hr"
```

```js
import { kts_console, visco, init } from "@bogo/kxfm"
```

```js
diagram_styles
```

```js
diagram_toggles = [highlight_all_timelines_of_event]
```

```js
diagram_options = // custom edge styles which are better suited for a river network diagram
{
  return { 
    repeat_entity_in_future : true // show each person's future self
  } 
}
```

```js
import { timelines, Story, StoryToDotRenderer, dot2svg, diagram_styles, highlight_all_timelines_of_event } 
with { diagram_toggles, diagram_options }
from "@bogo/timelib4"
```
